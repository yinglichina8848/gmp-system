<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TokenBlacklistServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">auth-service</a> &gt; <a href="index.source.html" class="el_package">com.gmp.auth.service.impl</a> &gt; <span class="el_source">TokenBlacklistServiceImpl.java</span></div><h1>TokenBlacklistServiceImpl.java</h1><pre class="source lang-java linenums">package com.gmp.auth.service.impl;

import com.gmp.auth.service.TokenBlacklistService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.UUID;

/**
 * 令牌黑名单服务实现
 * 使用Redis存储已撤销的JWT令牌
 */
@Service
<span class="fc" id="L20">public class TokenBlacklistServiceImpl implements TokenBlacklistService {</span>
    
<span class="fc" id="L22">    private static final Logger logger = LoggerFactory.getLogger(TokenBlacklistServiceImpl.class);</span>
    
    private static final String BLACKLIST_PREFIX = &quot;token:blacklist:&quot;;
    
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    
    @Override
    @Cacheable(value = &quot;revokedTokens&quot;, key = &quot;#token&quot;)
    public boolean isTokenBlacklisted(String token) {
<span class="fc bfc" id="L32" title="All 2 branches covered.">        if (token == null) {</span>
<span class="fc" id="L33">            return false;</span>
        }
        
        // 使用Redis检查令牌是否在黑名单中
<span class="fc" id="L37">        String key = BLACKLIST_PREFIX + generateTokenKey(token);</span>
<span class="fc" id="L38">        Boolean exists = redisTemplate.hasKey(key);</span>
<span class="fc bfc" id="L39" title="All 4 branches covered.">        return exists != null &amp;&amp; exists;</span>
    }
    
    @Override
    @CacheEvict(value = &quot;revokedTokens&quot;, key = &quot;#token&quot;)
    public void blacklistToken(String token, long expiration) {
<span class="fc bfc" id="L45" title="All 2 branches covered.">        if (token == null) {</span>
<span class="fc" id="L46">            logger.warn(&quot;尝试将空令牌加入黑名单&quot;);</span>
<span class="fc" id="L47">            return;</span>
        }
        
        try {
            // 生成令牌的键
<span class="fc" id="L52">            String key = BLACKLIST_PREFIX + generateTokenKey(token);</span>
            
            // 计算过期时间
<span class="fc" id="L55">            long now = System.currentTimeMillis();</span>
<span class="fc" id="L56">            long ttl = Math.max(1, expiration - now); // 确保至少有1毫秒的过期时间</span>
            
            // 将令牌加入黑名单并设置过期时间
<span class="fc" id="L59">            redisTemplate.opsForValue().set(key, System.currentTimeMillis(), Duration.ofMillis(ttl));</span>
<span class="fc" id="L60">            logger.debug(&quot;令牌已成功加入黑名单，过期时间: {}毫秒&quot;, ttl);</span>
<span class="fc" id="L61">        } catch (Exception e) {</span>
<span class="fc" id="L62">            logger.error(&quot;将令牌加入黑名单失败: {}&quot;, e.getMessage());</span>
<span class="fc" id="L63">        }</span>
<span class="fc" id="L64">    }</span>
    
    @Override
    @CacheEvict(value = &quot;revokedTokens&quot;, key = &quot;#token&quot;)
    public void removeTokenFromBlacklist(String token) {
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (token == null) {</span>
<span class="fc" id="L70">            return;</span>
        }
        
        try {
<span class="fc" id="L74">            String key = BLACKLIST_PREFIX + generateTokenKey(token);</span>
<span class="fc" id="L75">            redisTemplate.delete(key);</span>
<span class="fc" id="L76">            logger.debug(&quot;令牌已从黑名单中移除&quot;);</span>
<span class="fc" id="L77">        } catch (Exception e) {</span>
<span class="fc" id="L78">            logger.error(&quot;从黑名单中移除令牌失败: {}&quot;, e.getMessage());</span>
<span class="fc" id="L79">        }</span>
<span class="fc" id="L80">    }</span>
    
    @Override
    public void cleanExpiredTokens() {
        // Redis会自动过期，不需要手动清理
        // 此方法保留用于兼容性和未来扩展
<span class="fc" id="L86">        logger.debug(&quot;清理过期的黑名单令牌&quot;);</span>
<span class="fc" id="L87">    }</span>
    
    /**
     * 生成令牌的键
     * 为了安全考虑，不对原始令牌进行哈希
     */
    private String generateTokenKey(String token) {
        // 使用UUID来确保键的唯一性
        // 在实际应用中，可以考虑使用令牌的签名部分或ID部分
<span class="fc" id="L96">        return UUID.nameUUIDFromBytes(token.getBytes()).toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>